/*****************************************************************************
 * Copyright (c) 2014 CEA LIST.
 *
 *    
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Ed Seidewitz (MDS) - Initial implementation
 * 
 *****************************************************************************/
modeltype Alf uses "http://www.omg.org/spec/ALF/20120827";
modeltype UML uses "http://www.eclipse.org/uml2/4.0.0/UML";

transformation UML2Alf(in uml : UML, out alf : Alf);

main() {
  var rootObjects := uml.rootObjects();
  model := rootObjects[Model]->any(true);
  if model = null then
  		rootObjects[Namespace]->map toUnitDefinition()
  else
  	model.packagedElement[Namespace][not name.startsWith("$")]->
  	  map toUnitDefinition()
  endif;
}

property model : Model;

// Elements

abstract mapping Element::toDocumentedElement() : DocumentedElement {
	self.ownedComment->forEach(c) {
	  if c.getAppliedStereotype("ActionLanguage::TextualRepresentation") = null then
  	  // Note: The syntax can only handle one documentation comment on an element.
  		documentation := "/**" + c.body + "*/"
		endif;	
	}
}

// Named Elements

mapping NamedElement::toMember() : Member 
  inherits Element::toDocumentedElement {
  definition := self.map toDefinition();	
  visibility := toVisibilityString(self.visibility);
  annotation := self.getAppliedStereotypes()->toAnnotation();
}

query Stereotype::toAnnotation() : StereotypeAnnotation {
  var qualifiedName := self.qualifiedName;
  if qualifiedName.startsWith("StandardProfile::") then
    qualifiedName := qualifiedName.substring(17, qualifiedName.length())
  endif;
  return object StereotypeAnnotation {
    stereotypeName := qualifiedName.toAlfQualifiedName(null);
    // TODO: Handle tagged values.
  }
}

query NamedElement::alfQualifiedName(context : NamedElement) : QualifiedName {
	return self.NamedElement_alfQualifiedName(context);
}

query NamedElement::NamedElement_alfQualifiedName(context : NamedElement) : QualifiedName {
  var namespace := if context = null then null else context.namespace endif;
  return 
    if namespace <> null and namespace.member->includes(self) then
    	let names = namespace.getNamesOfMember(self) in
    	if names->isEmpty() or names->includes(self.name) then
    	  self.name.toAlfQualifiedName(null)
    	else
    	  names->any(true).toAlfQualifiedName(null)
    	endif
    else
      self.qualifiedName.toAlfQualifiedName(context)
    endif;
}

query NamedElement::alfName() : String {
	return toName(self.name);
}

query toVisibilityString(visibility : VisibilityKind) : String {
  return
    if visibility = null or visibility = VisibilityKind::package then null
    else if visibility = VisibilityKind::private then "private"
    else if visibility = VisibilityKind::protected then "protected"
    else if visibility = VisibilityKind::public then "public"
    endif endif endif endif
}

query String::toAlfQualifiedName(context : NamedElement) : QualifiedName {
  var qualifiedName = object QualifiedName {
    isAmbiguous := false;
  };
  var names := self.tokenize("::");
  if names->size() > 1 and context <> null then {
    var unqualifiedName := names->last();
    if context.namespace <> null and
      (context.namespace.umlQualifiedName() + "::").startsWith(
        self.substring(1, self.length() - unqualifiedName.length())) then
      names := Sequence{unqualifiedName}
    else if (model <> null and names->at(1) = model.name or 
        names->at(1) = "PrimitiveTypes") then
      names := names->subSequence(2, names->size())
    else if names->size() > 2 and names->at(1) = "FoundationalModelLibrary" then
      names := names->subSequence(3, names->size())
    else if names->size() > 3 and 
            names->at(1) = "Alf" and names->at(2) = "Library" then
      names := names->subSequence(4, names->size())
    endif endif endif endif
  } endif;
  names->forEach (n) {
	qualifiedName.nameBinding += 
	  object NameBinding {
		name := toName(n);
	  }
  };
  return qualifiedName;
}

// Return the UML qualified name, but allowing for empty names.
query NamedElement::umlQualifiedName() : String {
	var name := if self.name->isEmpty() then "" else self.name endif;
	return
		if self.namespace->isEmpty() then name
		else self.namespace.umlQualifiedName() + "::" + name
		endif;
}

abstract mapping NamedElement::toMemberDefinition() : MemberDefinition
{
  name := toName(self.name);
}

query toName(name : String) : String {
  return
   if name = null or name.isIdentifier() then name
   else name.toRestrictedName()
   endif;   	
}

query String::isIdentifier() : Boolean {
	return self.matches("[a-zA-z_][a-zA-z_0-9]*") and not self.isReservedWord();
}

property reservedWords : Set(String) = Set{
  "abstract", "accept", "active", "activity", "allInstances", "any",
  "as", "assoc", "break", "case", "class", "classify", "clearAssoc",
  "compose", "createLink", "datatype", "default", "destroyLink", "do",
  "else", "enum" , "for", "from", "hastype", "if", "import", "in",
  "inout", "instanceof", "let", "namespace", "new", "nonunique", "null",
  "or", "ordered", "out", "package", "private", "protected", "public",
  "receive", "redefines", "reduce", "return", "sequence", "specializes",
  "super", "signal", "switch", "this", "to", "while"
};

query String::isReservedWord() : Boolean {
	return reservedWords->includes(self);
}

query String::toRestrictedName() : String {
	return "'" + self.
	 replace("\\", "\\\\").
	 replace("\b", "\\b").
	 replace("\t", "\\t").
	 replace("\n", "\\n").
	 replace("\f", "\\f").
	 replace("\r", "\\r").
	 replace("'", "\\'") +
	 "'";
}

mapping NamedElement::toDefinition() : MemberDefinition
  disjuncts
    Property::toPropertyDefinition,
    Operation::toOperationDefinition,
    Reception::toReceptionDefinition,
    Enumeration::toEnumerationDefinition,
    EnumerationLiteral::toEnumerationLiteralName,
    Namespace::toNamespaceDefinition,
    Parameter::toFormalParameter;

// Namespaces

mapping Namespace::toUnitDefinition() : UnitDefinition 
  inherits Element::toDocumentedElement {
  if self.namespace <> null and self.namespace <> model then
    namespaceName := self.namespace.alfQualifiedName(null)
  endif;
	definition := self.map toNamespaceDefinition();
	_import := self.elementImport->map toElementImportReference();
	_import += self.packageImport->map toPackageImportReference();
  annotation := self.getAppliedStereotypes()->toAnnotation();
}

mapping ElementImport::toElementImportReference() : ElementImportReference {
	visibility := toVisibilityString(self.visibility);
	referentName := self.importedElement.alfQualifiedName(null);
	alias := self.alias;
}

mapping PackageImport::toPackageImportReference() : PackageImportReference {
	visibility := toVisibilityString(self.visibility);
	referentName := self.importedPackage.alfQualifiedName(null);
}

mapping Namespace::toNamespaceDefinition() : NamespaceDefinition
  disjuncts Classifier::toNamespaceDefinition, Package::toPackageDefinition;

// Packages

mapping Package::toPackageDefinition() : PackageDefinition
  inherits NamedElement::toMemberDefinition {
	ownedMember := self.packagedElement->map toMember();
}

// Classifiers

abstract mapping Classifier::toClassifierDefinition() : ClassifierDefinition
  inherits NamedElement::toMemberDefinition
  when { self.templateBinding->isEmpty() } {
  isAbstract := self.isAbstract;
  var generals := self.general;
  if generals->notEmpty() then
    specialization := object QualifiedNameList {
    	name := generals.alfQualifiedName(self);
    }
  endif;
  if self.ownedTemplateSignature <> null then {
    ownedMember += self.ownedTemplateSignature.parameter
      [uml::ClassifierTemplateParameter]->map toTemplateParameter()
  } endif;
  isStub := false;
}

mapping Classifier::toNamespaceDefinition() : NamespaceDefinition
  disjuncts
    Activity::toActivityDefinition,
    Class::toActiveClassDefinition,
    Class::toPassiveClassDefinition,
    Enumeration::toEnumerationDefinition,
    DataType::toDataTypeDefinition,
    Association::toAssociationDefinition,
    Signal::toSignalDefinition,
    Signal::toSignalReceptionDefinition;
    

// ClassifierTemplateParameters

mapping uml::ClassifierTemplateParameter::toTemplateParameter() : Member {
  definition := object ClassifierTemplateParameter {
    name := self.parameteredElement.oclAsType(Classifier).name;
    if self.constrainingClassifier->notEmpty() then 
      specialization := object QualifiedNameList {
        name += self.constrainingClassifier->any(true).alfQualifiedName(
          self.signature.template.oclAsType(NamedElement));
      }
    endif;
  };
}

// Bound Classifiers

query Classifier::alfQualifiedName(context : NamedElement) : QualifiedName {
  return
    if (self.templateBinding->isEmpty()) then {
      return self.NamedElement_alfQualifiedName(context)
    } else {
      var templateBinding := self.templateBinding->any(true);
      var template := templateBinding.signature.template.oclAsType(NamedElement);
      var qualifiedName := template.alfQualifiedName(context);
      var parameterSubstitutions := templateBinding.parameterSubstitution;
      var finalBinding := 
        if parameterSubstitutions->size() <= 1 then
          object PositionalTemplateBinding {
          	argumentName := parameterSubstitutions->toArgumentName(context);
          }
        else
          object NamedTemplateBinding{
            substitution := templateBinding.parameterSubstitution->
              toTemplateParameterSubstitution(context);
          }
        endif;
      qualifiedName.nameBinding->last().binding := finalBinding;
      return qualifiedName;
    } endif;
}

query uml::TemplateParameterSubstitution::toTemplateParameterSubstitution(context : NamedElement) : TemplateParameterSubstitution {
  return
    object TemplateParameterSubstitution {
      parameterName := self.formal.parameteredElement.oclAsType(NamedElement).alfName();
      argumentName := self.toArgumentName(context);
    }
}

query uml::TemplateParameterSubstitution::toArgumentName(context : NamedElement) : QualifiedName {
	return self.actual.oclAsType(NamedElement).alfQualifiedName(context);
}

// Classes

abstract mapping Class::toClassDefinition() : ClassDefinition 
  inherits Classifier::toClassifierDefinition {
  ownedMember += self.nestedClassifier->map toMember();
  ownedMember += self.ownedBehavior->select(isDefaultValue())->map toMember(); // TODO: Remove
  ownedMember += self.ownedAttribute->reject(isInitializationFlag(self.name))->
    map toMember();
  // TODO: Filter out default constructor and destructor operations.
  ownedMember += self.ownedOperation->reject(isInitializationOperation(self.name))->
    map toMember();
}

query Behavior::isDefaultValue() : Boolean {
	return self.name.indexOf("$defaultValue$") > 0;
}

query Property::isInitializationFlag(className : String) : Boolean {
	return self.name <> null and self.name.startsWith(className + "$initializationFlag");
}

query Operation::isInitializationOperation(className : String) : Boolean {
  return self.name <> null and self.name.startsWith(className + "$initialization");
}

mapping Class::toPassiveClassDefinition() : ClassDefinition 
  inherits Class::toClassDefinition
  when { not self.isActive } {
	
}

// Active Classes

mapping Class::toActiveClassDefinition() : ActiveClassDefinition 
  inherits Class::toClassDefinition
  when { self.isActive } {
  // var receivedSignals := self.receivedSignals();
  // ownedMember += receivedSignals->map toSignalReception();
	ownedMember += self.ownedReception->
	  reject(reception | reception.signal.namespace = self)->
	  map toMember();
	if self.classifierBehavior <> null and self.classifierBehavior.oclIsKindOf(Activity) then {
	  classifierBehavior := self.classifierBehavior.oclAsType(Activity).
	    map toActivityDefinition();
	  classifierBehavior.isStub := false;
  } endif;
}

// Data Types

mapping DataType::toDataTypeDefinition() : DataTypeDefinition 
  inherits Classifier::toClassifierDefinition {
	ownedMember += self.ownedAttribute->map toMember();
}

mapping PrimitiveType::toMember() : Member
  inherits NamedElement::toMember {
  annotation += object StereotypeAnnotation {
    stereotypeName := "primitive".toAlfQualifiedName(null);
  }
}

// Associations

mapping Association::toAssociationDefinition() : AssociationDefinition 
  inherits Classifier::toClassifierDefinition {
	ownedMember += self.memberEnd->map toMember();
	if self.name->isEmpty() or self.name = "" then {
		name := "A";
		self.memberEnd.name->forEach(endName) {
			name := name + "_" + endName;
		};
		name := toName(name);
	} endif;
}

// Enumerations

mapping Enumeration::toEnumerationDefinition() : EnumerationDefinition 
  inherits Classifier::toClassifierDefinition {
	ownedMember += self.ownedLiteral->map toMember();
	ownedMember->forEach(m){m.visibility := null};
}

mapping EnumerationLiteral::toEnumerationLiteralName() : EnumerationLiteralName 
  inherits NamedElement::toMemberDefinition;

// Signals

mapping Signal::toSignalDefinition() : SignalDefinition 
  inherits Classifier::toClassifierDefinition 
  when { not self.isSignalReception() } {
	ownedMember += self.ownedAttribute->map toMember();
}

mapping Signal::toSignalReceptionDefinition() : SignalReceptionDefinition
  inherits Classifier::toClassifierDefinition 
  when { self.isSignalReception() } {
  ownedMember += self.ownedAttribute->map toMember();
}

query Signal::isSignalReception() : Boolean {
	return self.namespace.ownedMember[Reception]->
	 exists(reception | reception.signal = self)
}

// Activities

mapping Activity::toActivityDefinition() : ActivityDefinition 
  inherits Classifier::toClassifierDefinition {
	ownedMember += self.ownedParameter->map toMember();
	isStub := true;
}

mapping Activity::toUnitDefinition() : UnitDefinition
  inherits Namespace::toUnitDefinition {
  	definition.isStub := false;
  	definition.oclAsType(ActivityDefinition).body := object Block {};
  }

// Typed Elements

abstract mapping TypedElement::toTypedElementDefinition() : TypedElementDefinition {
	typeName :=
	  if self.type = null then 
	    null
	  else if self.oclIsKindOf(NamedElement) then
	    self.type.alfQualifiedName(self.oclAsType(NamedElement))
	  else 
	    self.type.alfQualifiedName(null)
	  endif endif;
	isAny := self.type = null;
}

abstract mapping MultiplicityElement::toTypedElementDefinition() : TypedElementDefinition {
  isMultiplicity := false;
  if not (self.lower = 1 and self.upper = 1) then {
  	lowerBound := self.lower.toString();
  	upperBound := if self.upper = -1 then "*" else self.upper.toString() endif;
  } endif;
	if self.isOrdered and not self.isUnique then {
	  isSequence := true;
	  isOrdered := false;
	  isNonunique := false;
	} else {
  	isOrdered := self.isOrdered;
  	isNonunique := not self.isUnique;
	} endif;
}

// Parameters

mapping Parameter::toTypedElementDefinition() : TypedElementDefinition
  inherits TypedElement::toTypedElementDefinition, MultiplicityElement::toTypedElementDefinition;

mapping Parameter::toFormalParameter() : FormalParameter 
  inherits NamedElement::toMemberDefinition {
  init {
  	if self.direction = ParameterDirectionKind::_return then
  	  result := object ReturnParameter{}
  	else
  	  result := object NonReturnParameter{}
  	endif
  }
	typePart := self.map toTypedElementDefinition();
	direction := self.direction.toParameterDirectionString();
}

mapping Parameter::toMember() : Member
  inherits NamedElement::toMember {
  	visibility := null;
}

query ParameterDirectionKind::toParameterDirectionString() : String {
	return
	  if self = ParameterDirectionKind::_in then "in"
	  else if self = ParameterDirectionKind::_out then "out"
	  else if self = ParameterDirectionKind::_inout then "inout"
	  else if self = ParameterDirectionKind::_return then "return"
	  endif endif endif endif;
}

// Properties

mapping Property::toTypedElementDefinition() : TypedElementDefinition 
  inherits TypedElement::toTypedElementDefinition, MultiplicityElement::toTypedElementDefinition {
	
}

mapping Property::toPropertyDefinition() : PropertyDefinition
  inherits NamedElement::toMemberDefinition {
	typePart := self.map toTypedElementDefinition();
	if self.defaultValue.oclIsKindOf(OpaqueExpression) then
	  initializer := self.defaultValue.oclAsType(OpaqueExpression).map toExpression(self)
	endif;
}

mapping OpaqueExpression::toExpression(context : NamedElement) : Expression {
  init {
  	result := object BehaviorInvocationExpression {
  	  target := self.behavior.alfQualifiedName(context);
  	  tuple := object PositionalTuple {
  	  	expression := OrderedSet{};
  	  }
  	};
  }
  // TODO: Map default values to true initializer expressions.
}

// Operations

mapping Operation::toOperationDefinition() : OperationDefinition 
  inherits NamedElement::toMemberDefinition {
	isAbstract := self.isAbstract;
	isStub := true;
	var parameters := self.ownedParameter;
	if self.isConstructor() then
	  parameters := parameters->reject(direction = ParameterDirectionKind::_return)
	endif;
	ownedMember := parameters->map toMember();
}

query Operation::isConstructor() : Boolean {
	return self.getAppliedStereotype("StandardProfile::Create") <> null;
}

// Receptions

mapping Reception::toReceptionDefinition() : ReceptionDefinition {
	signalName := self.signal.alfQualifiedName(self);
}
